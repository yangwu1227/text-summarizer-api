{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Workflows","text":""},{"location":"#environment-setup","title":"Environment Setup","text":""},{"location":"#install-pdm","title":"Install PDM","text":"<p>The dependency manager used in this project is pdm. To install it, run the following command:</p> <pre><code>$ curl -sSL https://pdm-project.org/install-pdm.py | python3 -\n</code></pre> <p>Or, alternatively, other installation methods can be used.</p>"},{"location":"#install-dependencies","title":"Install Dependencies","text":"<p>The dependencies are broken into groups:</p> <ul> <li> <p>Default dependencies: required for the core functionality of the project in production.</p> </li> <li> <p>Development dependencies: required for development, testing, and documentation.</p> </li> </ul> <p>The specified python version in <code>pyproject.toml</code> is <code>&gt;=3.11</code>, and so a python 3.11 interpreter should be used. </p>"},{"location":"#conda","title":"Conda","text":"<p>To do so with conda:</p> <pre><code>$ conda search python | grep \" 3\\.\\(11\\)\\.\"\n$ conda create --name text_summarizer_api -y python=3.11.9\n$ conda activate text_summarizer_api\n$ pdm use -f $(which python3)\n$ pdm install\n</code></pre>"},{"location":"#pyenv","title":"Pyenv","text":"<p>To do so with pyenv and virtualenv, use the pdm venv command:</p> <pre><code>$ pyenv install --list | grep \" 3\\.\\(11\\)\\.\" \n$ pyenv install 3.11.9\n$ pdm venv create --name text_summarizer_api --with virtualenv 3.11.9 \n# To activate the virtual environment\n$ eval $(pdm venv activate text_summarizer_api) \n$ pdm install\n</code></pre> <p>Use <code>--with venv</code> to create the virtual environment using <code>venv</code> (comes with standard library) instead of <code>virtualenv</code> (third-party package but more performant). To create the venv in the project root instead of <code>pdm config venv.location</code>, omit the <code>--name</code> option:</p> <pre><code>$ pdm config venv.in_project true\n$ pdm venv create --with venv 3.11.9\n</code></pre>"},{"location":"#docker-compose","title":"Docker Compose","text":"<p>The development environment is set up using Docker Compose. This setup defines two services: </p> <ul> <li> <p>web: sets up the application based on <code>dev.Dockerfile</code>.</p> </li> <li> <p>wev-db: sets up a PostgreSQL database based on <code>db.Dockerfile</code>, which simply Adds a <code>.sql</code> file to the container at <code>/docker-entrypoint-initdb.d/</code>. Two databases are created: <code>web_dev</code> for development and <code>web_test</code> for testing; neither is used in production.</p> </li> <li> <p>web-redis: sets up a redis server for rate limiting.</p> </li> </ul> <pre><code>name: 'text-summarizer-api'\n\nservices:\n\n  web:\n    build:\n      context: ./project\n      dockerfile: docker/dev.Dockerfile\n    container_name: dev-api\n    command: uvicorn app.main:app --reload --workers 1 --host 0.0.0.0 --port 8000\n    volumes:\n      - ./project/app:/opt/project/app\n      - ./project/tests:/opt/project/tests\n      - ./project/pyproject.toml:/opt/project/pyproject.toml\n      - ./project/migrations:/opt/project/migrations\n    ports:\n      - 8004:8000\n    environment:\n      - ENVIRONMENT=dev\n      - TESTING=0\n      - DOCS_URL=/docs\n      - DATABASE_URL=postgres://postgres:postgres@web-db:5432/web_dev       \n      - DATABASE_TEST_URL=postgres://postgres:postgres@web-db:5432/web_test  \n      - REDIS_ENDPOINT=web-redis:6379\n      - REDIS_PASSWORD=redis\n    depends_on:\n      - web-db\n      - web-redis\n\n  web-db:\n    build:\n      context: ./project\n      dockerfile: docker/db.Dockerfile\n    container_name: db\n    expose:\n      - 5432\n    environment:\n      - POSTGRES_USER=postgres\n      - POSTGRES_PASSWORD=postgres\n\n  web-redis:\n    image: redis:bookworm\n    container_name: redis\n    expose:\n      - 6379\n    command: [\"redis-server\", \"--requirepass\", \"redis\"]\n</code></pre>"},{"location":"#build-and-run-the-services","title":"Build and Run the Services","text":"<p>Note: All the commands should be run from the root of the project where <code>compose.yml</code> is located. In addition, Compose V2 is used, so the <code>docker-compose</code> command is replaced with <code>docker compose</code>.</p> <p>To build the images and run the containers in the background:</p> <pre><code>$ docker compose up --detach --build\n</code></pre> <p>Directories such as <code>app/</code>, <code>tests/</code>, <code>migrations/</code>, and the <code>pyproject.toml</code> file are bind-mounted to their respective counterparts in the <code>web</code> service container. This setup allows for automatic reloading of the application when changes are made to the code during development.</p> <p>To stop the containers without removing them:</p> <pre><code>$ docker compose stop\n</code></pre> <p>To stop, remove the containers, and remove named volumes:</p> <pre><code>$ docker compose down --volumes\n</code></pre>"},{"location":"#logs","title":"Logs","text":"<p>To view the logs of the services:</p> <pre><code>$ docker compose logs &lt;service-name&gt;\n</code></pre>"},{"location":"#interactive-shell","title":"Interactive Shell","text":"<p>To run an interactive shell in a service:</p> <pre><code># Or /bin/bash\n$ docker compose exec &lt;service-name&gt; /bin/sh\n</code></pre>"},{"location":"#database-migrations","title":"Database Migrations","text":"<p>The database migrations are managed using aerich, which is a tool specifically designed for Tortoise-ORM.</p>"},{"location":"#first-time-setup","title":"First Time Setup","text":""},{"location":"#configuration","title":"Configuration","text":"<p>To set up the initial config file and generate the root migrate location:</p> <pre><code>$ docker compose exec &lt;service-name&gt; aerich init -t app.db.TORTOISE_ORM\n</code></pre> <p>The <code>-t</code> flag specifies the module path to the Tortoise-ORM settings inside the <code>app.db</code> module. This will add a <code>tool.aerich</code> section to the <code>pyproject.toml</code> file.</p>"},{"location":"#initialize-database","title":"Initialize Database","text":"<p>To initialize the database:</p> <pre><code>$ docker compose exec &lt;service-name&gt; aerich init-db\n</code></pre> <p>This will create the tables in the database based on the models defined in <code>app/models/</code> along with the first migration file in the <code>migrations/</code> directory.</p>"},{"location":"#migration-workflow","title":"Migration Workflow","text":"<p>From this point on, since the local <code>migrations/</code> directory is synced with the <code>migrations/</code> directory on the container (for both <code>prod</code> &amp; <code>dev</code>), each time a change is made to the model, the following steps should be taken:</p> <ol> <li>In development mode, update the model in <code>app/models/</code> and run the following command to generate a new migration:</li> </ol> <pre><code>$ docker compose exec &lt;service-name&gt; aerich migrate --name &lt;migration-name&gt;\n</code></pre> <ol> <li>Apply the migration in development mode:</li> </ol> <pre><code>$ docker compose exec &lt;service-name&gt; aerich upgrade\n</code></pre> <ol> <li> <p>Run tests and any other necessary checks.</p> </li> <li> <p>Merge the changes to the <code>main</code> branch, which will trigger a deployment to the production environment. </p> </li> <li> <p>Once the changes are deployed, apply the migration in production via the heroku CLI:</p> </li> </ol> <pre><code>$ heroku run aerich upgrade --app &lt;app-name&gt;\n</code></pre> <p>See the aerich's usage documentation for more commands and details.</p>"},{"location":"#psql","title":"PSQL","text":"<p>The PostgreSQL database within the docker container can be accessed using psql, a terminal-based front-end to PostgreSQL.</p> <pre><code>$ docker compose exec -it &lt;service-name&gt; psql -U &lt;username&gt;\n</code></pre>"},{"location":"#connect","title":"Connect","text":"<p>To connect to a specific PostgreSQL database within the server:</p> <pre><code>$ \\c &lt;database-name&gt;\n</code></pre>"},{"location":"#list-tables","title":"List Tables","text":"<p>To list the tables in the connected database:</p> <pre><code>$ \\dt\n</code></pre>"},{"location":"#quit","title":"Quit","text":"<p>To quit the <code>psql</code> shell:</p> <pre><code>$ \\q\n</code></pre>"},{"location":"#rate-limiting-with-redis","title":"Rate Limiting with Redis","text":"<p>Rate limiting is implemented using fastapi-limiter, which requires Redis to store the rate limiting data. Redis runs locally via Docker Compose in development and testing environments, while in production, Redis Cloud is used.</p>"},{"location":"#local-redis-setup","title":"Local Redis Setup","text":"<p>The Redis service is defined in <code>compose.yml</code>:</p> <pre><code>services:\n  web-redis:\n    image: redis:bookworm\n    container_name: redis\n    expose:\n      - 6379\n    command: [\"redis-server\", \"--requirepass\", \"redis\"]\n</code></pre> <p>Redis is exposed internally for communication between services. The application connects to Redis through the <code>REDIS_ENDPOINT</code> and <code>REDIS_PASSWORD</code> environment variables.</p>"},{"location":"#ci-redis-setup","title":"CI Redis Setup","text":"<p>In the CI environment, a Redis service is set up in an independent container:</p> <ul> <li>Create a network that the Redis service and the application service can connect to:</li> </ul> <pre><code>- name: Create Docker network\n  id: create-docker-network\n  run: docker network create test-network\n</code></pre> <ul> <li>Start the Redis service (pulling the image from Docker Hub):</li> </ul> <pre><code>- name: Start redis container\n  id: start-redis-container\n  run: |\n    docker run \\\n      --name web-redis \\\n      --network test-network \\\n      --detach \\\n      --expose 6379 \\\n      redis:bookworm \\ \n      redis-server --requirepass redis\n</code></pre> <ul> <li>When running the development container, connect to the same network:</li> </ul> <pre><code>- name: Run docker container\n  id: run-docker-container\n  run: |\n    docker run \\\n      --name test-container \\\n      --network test-network \\\n      --detach \\\n      -e PORT=8765 \\\n      -e ENVIRONMENT=dev \\\n      -e DATABASE_URL=\"${DB_URL}\" \\\n      -e DATABASE_TEST_URL=\"${DB_URL}\" \\\n      -e REDIS_ENDPOINT=web-redis:6379 \\\n      -e REDIS_PASSWORD=redis \\\n      -p 5003:8765 \\\n      ${{ env.IMAGE }}:latest\n</code></pre>"},{"location":"#production-redis-setup","title":"Production Redis Setup","text":"<p>In production, a free Redis Cloud database is utilized. To set up a Redis Cloud account, refer to this guide. After creating the account, follow the instructions in this guide to link it to Heroku.</p> <p>The following information from the Redis Cloud console is required:</p> <ul> <li>Public endpoint</li> <li>Password</li> </ul> <p>It is important to keep this information secure, as it will be necessary for the application to connect to the Redis database.</p>"},{"location":"#application-redis-initialization","title":"Application Redis Initialization","text":"<p>Redis is initialized in the application using a lifespan context manager in <code>app/db.py</code>:</p> <pre><code>@asynccontextmanager\nasync def lifespan(app: FastAPI) -&gt; AsyncGenerator[None, None]:\n    redis_endpoint = os.getenv(\"REDIS_ENDPOINT\")\n    redis_encoded_password = quote(os.getenv(\"REDIS_PASSWORD\"), safe=\"\")\n    redis_url = f\"redis://:{redis_encoded_password}@{redis_endpoint}\"\n    redis_connection = redis.from_url(redis_url, encoding=\"utf8\")\n    await FastAPILimiter.init(redis_connection)\n\n    async with RegisterTortoise(\n        app=app,\n        db_url=os.environ.get(\"DATABASE_URL\"),\n        modules={\"models\": [\"app.models.tortoise_model\"]},\n        generate_schemas=False,\n        add_exception_handlers=True,\n    ):\n        yield\n\n    await FastAPILimiter.close()\n</code></pre> <p>This implementation ensures that <code>fastapi-limiter</code> effectively manages Redis-based rate limiting. The <code>lifespan</code> context manager is responsible for establishing a connection to Redis at the start of the application and closing it after the application has finished running. </p> <p>Before deploying to Heroku, ensure that the <code>REDIS_ENDPOINT</code> (public endpoint) and <code>REDIS_PASSWORD</code> (password) environment variables are set as config vars in the Heroku application settings.</p>"}]}